\chapter{Conclusion}
\section{Related Work}
Our work was inspired by the work of Stickel \cite{stickel_path-indexing_1989} who introduced path indexing as an alternative to discrimination trees. In their work, they also showed that path indexing is a promising competitor but that each technique has advantages and drawbacks. This observation was further examined by McCune \cite{mccune_experiments_1992}. By considering various optimisations for both techniques, they arrived at a more detailed conclusion. A study of these indices, in addition to abstraction trees and substitution trees was also conducted in \cite{carbonell_comparison_1995}.

Although we embedded first-order path indexing in the higher-order context of Isabelle and generalised the index to store arbitrary values instead of terms, the results we obtained generally agree with said literature. The consensus is that path indexing is superior to the variant of discrimination trees used in Isabelle for insertion, deletion and instances retrieval. On the other hand, discrimination trees dominate for variants and generalisations queries. Besides the insertion and deletion operations, which are slightly slower due to the combination with termtables, the results agree with our findings.

One significant difference to previous results are our findings for unifiable queries. Although their results are mixed, discrimination trees are found to be either comparable or superior. While we also found them to be comparable at small sizes, path indexing is significantly faster when 200 or more terms are indexed. This may be a result of the applicative style disrupting the performance of discrimination trees or the random generation of terms not accurately representing the terms of real applications and requires further investigation.

\section{Summary and Future Work}
We presented both path indexing and discrimination tree indexing and described the process of adapting the path index to Isabelle/ML, including the embedding of first-order terms in higher-order terms and the generalisation to indexing arbitrary values. In addition, we also considered optimisations to speed up the set operations, whose performance is crucial.

By combining path indexing with termtables (balanced 2-3 trees) and using integer identifiers in place of terms for lookup comparisons in the path index, we not only sped up all set operations but also supplemented the slow variants query of the path index with the exact lookup of the termtable. This is an opportunity to investigate other potential combinations of term indices. In addition, the use of a termtable, that distinguishes variables, enables the implementation of an exact duplicate detection, negating some of the caveats mentionend in \cref{caveats}.

Although current term indexing techniques in Isabelle/ML are able to deal with higher-order terms, they are optimised for the first-order case.
Generalising term indices to handle higher-order terms correctly is, unfortunately, highly complicated as some queries may no longer be decidable \cite{goldfarb_undecidability_1981}. Nevertheless, overapproximating term indices have been investigated and offer acceptable performance \cite{pientka_higher-order_2009,libal_towards_2016}. Implementing such indices may prove to be challenging but also highly desirable.

While implementing path indexing, we took care to unify the interface with that of discrimination trees. This allows a user of either structure to simply swap the used term index for the other one. Moreover, this clears the way to easily add additional term indices such as substitution trees, which offer better performance for queries while compromising in sertion speed and memory requirements \cite{carbonell_comparison_1995}.

Lastly, we evaluated the performance of our implementation of path indexing in comparison to the existing implementation of discrimination trees in Isabelle/ML. While our evaluation largely reflects the results of the literature, they must be taken with a grain of salt as the generated terms are, after all, artificial and do not accurately represent real applications. Evaluating their performance on actual theories in Isabelle should be, thanks to the interface, relatively simple once proof methods are adapted to the minor changes in the interface.
