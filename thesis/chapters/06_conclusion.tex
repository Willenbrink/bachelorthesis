\chapter{Conclusion}
\section{Related Work}
Our work was inspired by the work of Stickl \cite{noauthor_path-indexing_nodate} that introduced path indexing as an alternative to discrimination trees. In their work, they also showed that path indexing is a promising competitor but that each technique has advantages and drawbacks. This observation was further examined by McCune \cite{mccune_experiments_1992}. By considering various optimisations for both techniques, they arrived at a more detailed conclusion. A study of these indices, in addition to abstraction trees and substitution trees was also conducted in \cite{carbonell_comparison_1995}.

\todo{Move this to evaluation?}
Although we embedded first-order path indexing in the higher-order context of Isabelle and generalised the index to store arbitrary values instead of terms, the results we obtained generally agree with the above literature. The consensus of the literature is, that path indexing is superior to the variant of discrimination trees used in Isabelle for insertion, deletion and instances retrieval. On the other hand, the discrimination trees dominate in regards to variants and generalisations retrieval. Besides the insertion and deletion that are falsified due to the combination with termtables, these results agree with our findings.

One significant difference to other literature are our findings on the unifiables query. Although their results are mixed, discrimination trees are found to be either comparable or superior. While we also found them to be comparable at small sizes, path indexing is significantly faster when 200 or more terms are indexed. This may be a result of the applicative style disrupting the performance of discrimination trees or the random generation of terms not accurately representing the terms of real applications.

\section{Summary and Future Work}
We presented both path indexing and discrimination tree indexing and described the process of adapting the path index to Isabelle/ML, including the embedding of first-order terms in higher-order terms and the generalisation to indexing arbitrary values. In addition, we also considered optimisations to speed up the set operations, whose performance is essential to the queries, deletion and, to a lesser extent, also insertion.

By combining path indexing with termtable, a balanced 2-3 tree, and using identifiers for comparison in the path index, we not only sped up all set operations but also supplemented the slow variants query of the path index with the exact lookup of the termtable. This is an opportunity to investigate other potential combinations of term indices. In addition, the use of a termtable, that distinguishes variables, enables the implementation of an exact duplicate detection, negating some of the caveats mentionend in \cref{caveats}.

The indexing techniques implemented in Isabelle/ML so far are designed for first-order terms. As Isabelle/HOL, the higher-order theorem proving environment, is the most widespread instance of Isabelle, this restriction to first-order is somewhat problematic. While first-order logic is of course useful even in this contex, as exemplified by Sledgehammer calling exclusively first-order automated theorem provers \cite{bohme_sledgehammer_2010}, it is only a matter of time until a user desires a higher-order term index.

Generalising term indices to handle higher-order terms correctly is, unfortunately, highly complicated as some queries may no longer be decidable \cite{goldfarb_undecidability_1981}. Nevertheless, overapproximating term indices have been investigated and are achievable while retaining acceptable performance \cite{pientka_higher-order_2009,libal_towards_nodate}. Implementing such indices may prove to be challenging but also highly desirable.

While implementing path indexing, we took care to unify the interface with the discrimination trees. This allows a user of either to simply swap the used term index for the other. Due to path indexing excelling at instances queries and discrimination trees at generalisations queries, this is already beneficial. Nevertheless, a user may encounter a situation where neither provides acceptable performance. Therefore, it is desirable to implement additional, specialised indices.

For example, both path indexing and discrimination trees provide a balance of modification speed and query speed. If frequent modifications are required, they will both fail to provide acceptable performance. Likewise, if the set of indexed terms changes only infrequently, another term index may offer superior performance. One such promising index is the substitution tree which, although requiring a relatively large amount of memory and possessing bad insertion performance, is found to be superior in all queries in \cite{carbonell_comparison_1995}.

Lastly, we evaluated the performance of our implementation of path indexing in comparison to the implementation of discrimination tree. While our evaluation largely reflects the results of other literature, they must be taken with a grain of salt as the generated terms are, after all, artificial and do not accurately represent real applications. Evaluating their performance on actual theories in Isabelle should be, thanks to the interface, relatively simple once proof methods are adapted to the minor changes in the interface.
