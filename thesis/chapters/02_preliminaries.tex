\chapter{Preliminaries}
\section{First-Order Logic}
First-order logic is a formal language used to, amongst others, formalise reasoning, including artifical intelligence, logic programming and automated deduction systems. In this thesis we are only interested in terms. Therefore, we disregard formulas, relations and quantifiers. A more extensive introduction can be found in \cite{abiteboul_foundations_1995}.

A symbol is either a variable, a constant or a function. We choose all variables from the infinite set $V = \{x, y, z, x_{1}, x_{2}, ...\}$, all constants from the infinite set $C = \{a, b, c, d, c_{1}, c_{2}, ...\}$ and all functions from the infinite set $F = \{f, g, h, f_{1}, f_{2}, ...\}$. Whenever possible, we use only the first three symbols of each set for better readibility.

The arity of a symbol $arity(s)$ is a positive integer representing the number of arguments this symbol is applied to. All constants have a fixed arity of $0$ while every function $f$ has a fixed arity $arity(f) \geq 1$. A variable $x$ has an arbitrary but fixed arity.

A term in first-order logic is a symbol $s$ applied to $arity(s)$ arguments. We require all symbols $s$ to always be applied to an $arity(s)$-tuple of terms.

\subsection{Generalisation and Unification}
A substitution is a partial function $\rho : V \rightarrow T$. We denote by $t \rho = u$ the term obtained by applying the substitution $\rho$ to all variables $v$ both in $t$ and the domain of $\rho$. We write $[t_{1}/x_{1},...,t_{n}/x_{n}]$ for the substitution $\{x_{1} \rightarrow t_{1}, ..., x_{n} \rightarrow t_{n}\}$. Note that $\rho$ is applied only once to the original term, that is, $x [y/x, a/y] = y$ even though $y$ would be substituted by $a$ in the original term.

Given two terms $t, u$, we say that $t$ is a generalisation of $u$ and $u$ a instance or specialization of $t$ if and only if there exists a substitution $\rho$ such that $t \rho = u$. Similarly, we call $t$ and $u$ unifiable and $\rho$ a unifier if $t \rho = u \rho$. It can be seen that whenever $t$ is a generalisation of $u$ they are also unifiable.

\section{Lambda Calculus}
\todo{Define lambda calculus}

\section{Isabelle}
Isabelle is a generic interactive theorem prover supporting formal theories. By design, it uses a metalogic, called Isabelle/Pure, to embed other logics and provide a deduction framework. To do so, Isabelle/Pure uses a higher-order logic. The very basis of this metalogic are the \lam -terms within which the theorems and inference rules are embedded.

Isabelle is written for the most part in Standard ML (SML) and can also be extended at runtime. It is divided into a kernel, that has been verified and verifies the correctness of all proofs, and a userspace within which we can implement deduction methods for proofs.

\subsection{Term Representation in Isabelle}
The \lam -terms in Isabelle/Pure are used in many different contexts and are also used for embedding first-order logic terms. They are a variant of simply typed \lam -calculus and are built up recursively in an applicative style. They are defined, with minor differences for the sake of simplicity, as follows:
\begin{lstlisting}
datatype term =
    Const of string * typ
  | Free of string * typ
  | Var of string * typ
  | Bound of int
  | Abs of string * typ * term
  | $ of term * term
\end{lstlisting} %$
\begin{enumerate}
  \item \verb!Const! and \verb!Free! both represent a fixed symbol. Their distinction is related to the metalogic nature of Isabelle/Pure and is irrelevant in the context of term indexing.
  \item \verb!Var! represents a variable, i.e. it is a placeholder and can be replaced by an arbitrary term of the same type.
  \item \verb!Bound! is a variable bound by a lambda term encoded as a de Bruijn index.
  \item \verb!Abs! is an abstraction whose variable is given a name for better readability.
  \item $\textdollar$ represents the application of the first argument to the second one. As there are no tuples in this term representation, all functions are curried by default. $\textdollar$ is written infix.
\end{enumerate}

We will ignore the types of terms and simply assume type correctness at all points. The \lam -term $(\lam x.\ x)\ a$ can then be represented directly as \verb!Abs "x" (Bound 1)) $ Const "a"!. The application is left-associative, i.e. $f\ x\ y$ is written as \verb!Const "f" $ Var "x" $ Var "y"! whereas $f\ (g\ x)$ is written as \verb!Const "f" $ (Const "g" $ Var "x")!.

We can embed first-order terms in these \lam -terms. While variables with an arity of $0$ and constants map directly to \verb!Var! and \verb!Const! respectively. Likewise, the symbol of a function maps to a \verb!Const!. The function as a whole, the symbol and the tuple of terms which are the arguments, is represented by a chain of applications with each component mapped to a \lam -term. The term $f(a,g(x))$ is then represented by \verb!Const "f" \$ Const "a" \$ (Const "g" \$ Var "x")!. Note the braces around $g(x)$ to differentiate this term from $f(a,g,x)$.

We assume every term to consist of only \verb!Const!, \verb!Var! and $textdollar$. This avoids the overhead of distinguishing \verb!Const! and \verb!Free!. \verb!Abs! are not required for first-order terms and dangling \verb!Bounds!, that is, indices pointing to a non-existing abstraction, are excluded, too.

%This embedding will later be useful to map the concepts from first-order logic to the \lam calculus used in Isabelle. In addition we will require an inverse mapping as this will allow us to use term indices for \lam -terms representing higher-order terms.

%In first-order logic, we are often interested in determining whether a term is a generalisation of another term. This allows us to, for example, determine superfluous horn clauses. If the conclusion of one horn clause is a generalisation of the conclusion of another and each premise of the first is an instance of a premise of the second we can safely conclude that any model that satisfies the second horn clause also satisfies the first.
